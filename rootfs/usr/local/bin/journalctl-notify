#!/usr/bin/python3 -u

import asyncio
import contextlib
import json
import sys
from asyncio.subprocess import DEVNULL, PIPE, Process

# Sleeping a little bit is very important to prevent reaching the TasksMax limit of systemd.
# See: https://unix.stackexchange.com/questions/253903/creating-threads-fails-with-resource-temporarily-unavailable-with-4-3-kernel
# It can happen that you have many logs to report which could cause this script to spawn many notify-send processes and therefore
# reaching the TasksMax limit. It will basically crash.
SLEEP_BETWEEN_NOTIFY = 0.1


async def is_running(proc: Process) -> bool:
    with contextlib.suppress(asyncio.TimeoutError):
        await asyncio.wait_for(proc.wait(), 1e-6)
    return proc.returncode is None


async def try_process_notify(line: bytes) -> None:
    begin = line.find(b"NOTIFY")

    if begin == -1:
        return

    log = line[begin + len("NOTIFY") :].strip().decode()

    try:
        log = json.loads(log)
    except json.JSONDecodeError:
        print("Wrong log format:", log)
        return

    if len(log) == 3:
        urgency = log["urgency"]
        title = log["title"]
        body = log["body"]
        await asyncio.create_subprocess_exec(
            "/usr/bin/notify-send",
            "--urgency",
            urgency,
            title,
            body,
        )
        await asyncio.sleep(SLEEP_BETWEEN_NOTIFY)

    elif len(log) == 4:
        urgency = log["urgency"]
        icon = log["icon"]
        title = log["title"]
        body = log["body"]
        await asyncio.create_subprocess_exec(
            "/usr/bin/notify-send",
            "--urgency",
            urgency,
            "--icon",
            icon,
            title,
            body,
        )
        await asyncio.sleep(SLEEP_BETWEEN_NOTIFY)

    else:
        print("Wrong log format:", log)
        return


async def try_process_firewall_rejection(line_as_bytes: bytes) -> None:
    if line_as_bytes.find(b"FIREWALL REJECTED") == -1:
        return

    begin = line_as_bytes.find(b":")
    line = line_as_bytes[begin + 1 :].decode().strip()
    tokens = line.split()
    content: dict[str, str | None] = {}

    for token in tokens:
        key_value = token.split("=")

        if len(key_value) == 1:
            content[key_value[0]] = None
        elif len(key_value) == 2:
            content[key_value[0]] = key_value[1]
        else:
            error = f"Unable to parse: {key_value} from the following log:\n{line}"
            raise ValueError(error)

    # Process only TCP and UDP
    if "PROTO" not in content or content["PROTO"] not in ("TCP", "UDP"):
        return

    # Don't process rejected broadcast packets (too much spam)
    if "MACDST" in content and content["MACDST"] == "ff:ff:ff:ff:ff:ff":
        return

    try:
        src_addr = content["SRC"]
        dst_addr = content["DST"]
        dst_port = content["DPT"]
        proto = content["PROTO"]
        iface_in = content["IN"]
        iface_out = content["OUT"]
    except KeyError as ke:
        error = f"{ke} is missing from the following log:\n{line}"
        raise ValueError(error) from ke

    body = f"{src_addr} tried to reach {dst_addr}:{dst_port} ({proto})\n"

    if "REJECTED FORWARD" in line:
        chain = "FORWARD"
        body += f"From interface {iface_in} to {iface_out}"
    elif "REJECTED INPUT" in line:
        chain = "INPUT"
        body += f"To interface {iface_in}"
    elif "REJECTED OUTPUT" in line:
        # Don't send notification for blocked output (too much spam)
        return
    else:
        error = f"unexpected rejected token from the following log:\n{line}"
        raise ValueError(error)

    await asyncio.create_subprocess_exec(
        "/usr/bin/notify-send",
        "--urgency",
        "critical",
        f"FIREWALL {chain} DENIAL",
        body,
    )
    await asyncio.sleep(SLEEP_BETWEEN_NOTIFY)


async def main() -> None:
    journal_system = await asyncio.create_subprocess_exec(
        "journalctl",
        "--boot",
        "--system",
        "--follow",
        "--lines=all",
        stdout=PIPE,
        stderr=DEVNULL,
    )

    journal_user = await asyncio.create_subprocess_exec(
        "journalctl",
        "--boot",
        "--user",
        "--follow",
        "--lines=all",
        stdout=PIPE,
        stderr=DEVNULL,
    )

    while await is_running(journal_system) and await is_running(journal_user):
        for journal in (journal_system, journal_user):
            while (
                True
            ):  # Try to read as much lines as possible while there are some available
                try:
                    line = await asyncio.wait_for(
                        journal.stdout.readline(),
                        timeout=1,
                    )  # The lower the timeout, the higher the CPU usage
                except asyncio.TimeoutError:
                    # No new line available yet, try the next journal by breaking out
                    break

                try:
                    await try_process_notify(line)
                    await try_process_firewall_rejection(line)
                except Exception as exc:  # noqa: BLE001
                    await asyncio.create_subprocess_exec(
                        "/usr/bin/notify-send",
                        "--urgency",
                        "critical",
                        "JOURNALCTL NOTIFIER PARSER ERROR",
                        str(exc),
                    )
                    await asyncio.sleep(SLEEP_BETWEEN_NOTIFY)

    # This script should never exit, if it does something went wrong, exit with status 1
    print("Error: one of the subprocesses exited")

    await asyncio.create_subprocess_exec(
        "/usr/bin/notify-send",
        "--urgency",
        "critical",
        "JOURNALCTL NOTIFIER STOPPED",
        "One of the journalctl subprocess exited",
    )
    sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
